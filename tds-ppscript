#!/usr/bin/ruby
# -*- coding: UTF-8 -*-

require 'Find'
require 'open3'

$REPO_SOURCE = 'git@git.gametaptap.com:tds/client-sdk/tds-sdk-all/tdsspecs.git'
$REPO_NAME = 'tdsspecs'
$GIT_SOURCE = 'git@git.gametaptap.com:tds/client-sdk/tds-sdk-all/tds-all-libs-ios'
$PATH = "/Users/#{ENV['USER']}/Documents"

$USE_ORIGIN
$SPEC_NAME

def syscall cmd, msg = 'PP-ERROR', a_exit = true, a_verbose = true
    cmd = a_verbose ? "#{cmd} --verbose" : cmd
    stdout, stdeerr, status = Open3.capture3(cmd)
    if status.success?
        puts "#{cmd}:#{stdout}"
    else
        puts "#{cmd}(#{msg}):#{stdeerr}"
        if a_exit
            exit
        end
    end
    stdout
end

def matchPodspecFile path
    specPath = Dir["#{path}/*.podspec"][0]
    if specPath.length > 0
        specPath
    else
        puts "匹配podspec文件失败：目标路径的一级目录存在多个podspec文件"
        exit
    end
end

def cloneGit(git)
    syscall "cd #$PATH && rm -rf #$SPEC_NAME && git clone #{git}", "拉取仓库失败(#{git})"
end

def gitam (path, note)
    syscall "cd #{path} && git add . && git commit -m \"#{note}\" && git push", "提交代码失败"
end

def gittag(path, tag)
    syscall "cd #{path} && git tag #{tag} && git push --tags", "打Tag失败"
end

def findLocalRepoSource
    stdout = syscall "pod repo list", "获取本地pod源列表失败"
    repos = stdout.split(/\n/)
    hasRepo = 0
    repos.each do |repo|
        if repo.include?$REPO_SOURCE
            index = repos.index(repo) - 2
            $REPO_NAME = repos[index].strip
            hasRepo = 1
            break
        end
    end
    if !hasRepo
        syscall "pod repo add #$REPO_NAME #$REPO_SOURCE", "添加私有源失败"
    end
    $REPO_NAME
end

def updateLocalRepoSource
    puts "正在更新本地源:#{findLocalRepoSource}......"
    syscall "pod repo update #$REPO_NAME", "更新 #$REPO_NAME 失败"
end

def getVersion specP
    file = File.read specP 
    pattern = /s.version\s*=\s*'\K[^']*/m
    result = file.scan(pattern)[0]
    result
end

def alterVersion specP, version
    file = File.read specP 
    pattern = /s.version\s*=\s*'\K[^']*/m
    result = file.scan(pattern)[0]
    if version == '0'
        # 本地打包，不指定version
    elsif version == '-1'
        # 版本自增
        if result.length > 0
            vers = result.split('.')
            last = (Integer(vers[-1]) + 1).to_s
            vers[vers.length-1, 1] = last
            ver = vers.join '.'
            buffer = file.gsub pattern, ver
            if not File.writable? specP then
                #check out the file first
                File.open(specP).chmod(0755)
            end
            file = File.write(specP, buffer)
            result = ver
        end
    else 
        # 指定版本
        if result.length > 0
            buffer = file.gsub pattern, version
            if not File.writable? specP then
                #check out the file first
                File.open(specP).chmod(0755)
            end
            file = File.write(specP, buffer)
            result = version
        end
    end
    result
end

def podPackage path, name
    syscall "cd #{path} && pod package #{name} --force", "打包失败"
end

def podPublish
end

def replacePackageSource path, origin
    cnt = ""
    if origin
        cnt = " :git => '#$GIT_SOURCE/#$SPEC_NAME.git', :tag => s.version.to_s"
    else
        cnt = " :git => '#{File.expand_path("..", path)}'"
    end

    file = File.read path
    pattern = /s.source\s*=\s*{\K[^}]*/m
    if file.scan(pattern).length > 0
        buffer = file.gsub pattern, cnt
        if not File.writable? path then
            #check out the file first
            File.open(path).chmod(0755)
        end
    file = File.write(path, buffer)
    end
end

def publish (resultP, specP)
    puts "是否发版?(Y/N)："
    flag = gets.strip
    case flag
    when "Y","y"
        puts '请输入版本（e.g. 1.3.2-unstable），`-1`表示自增：'
        ver = gets.strip
        puts "正在更新本地podspec文件..."
        alterVersion specP, ver
        file = File.read specP
        puts file
        puts "正在提交代码..."
        gitam "#$PATH/#$SPEC_NAME", "#{getVersion(specP)} Updated"
        gittag "#$PATH/#$SPEC_NAME", getVersion(specP)
        puts "正在远端验证..."
        syscall "pod repo push #$REPO_NAME #{specP} --use-libraries --allow-warnings", "发版失败"
    when "N","n"
        syscall "open #{resultP}", "打开包地址失败", true, false
    else
        puts 'Illegal pargram.'
        publish resultP, specP
    end
end

def packageOrigin git
    puts "正在使用远端代码打包(#$SPEC_NAME):#{git}"
    puts '...'

    specP = matchPodspecFile "#$PATH/#$SPEC_NAME"
    specN = specP.split('/').at -1
    replacePackageSource specP, true
    repoP = "#$PATH/#$SPEC_NAME"
    podPackage repoP, specN
    resultP = "#{repoP}/#$SPEC_NAME-#{getVersion(specP)}/ios"
    puts "远端代码打包完成(#{resultP})"
    publish resultP, specP
end

def packageLocal path

    specP = matchPodspecFile path
    specN = specP.split('/').at -1
    $SPEC_NAME = specN.split('.').at 0
    puts "正在使用本地代码打包:#{specN}"
    puts '...'
    replacePackageSource specP, false
    podPackage path, specN
    resultP = "#{File.expand_path("..", specP)}/#$SPEC_NAME-#{getVersion(specP)}/ios"
    puts "本地代码打包完成(#{resultP})"
    publish resultP, specP
end

def package
    # 更新本地源
    updateLocalRepoSource
    # 打包
    if $USE_ORIGIN
        # 获取包名、版本号
        puts '请输入仓库名（e.g. tdsmomentsource）：'
        $SPEC_NAME = gets.strip
        # 拉取远端仓库
        gitS = "#$GIT_SOURCE/#$SPEC_NAME.git"
        puts "正在拉取远端仓库源码:#$SPEC_NAME"
        cloneGit gitS
        packageOrigin gitS
    else
        # 获取本地地址
        puts '请输入本地仓库地址（e.g. /Users/jocer/Documents/tdstapdbsource）：'
        path = gets.strip
        packageLocal path
    end
end

def s_gem_l n
    g_out = syscall 'gem list --local', '拉取gem列表失败'
    l_gems = g_out.split(/\n/)
    r = false
    l_gems.each do |g|
        if g.include? n
            r = true
            break
        end
    end
    if !r
        puts "gem未安装#{n},ruby当前版本是#{syscall('ruby -v', '获取ruby版本失败')}"
        puts "继续在homebrew中检索#{n}..."
        r = syscall("brew search #{n}", "homebrew未安装#{n}", false).length > 0 ? true : false
        if r 
            puts "homebrew已安装#{n}"
        end
    else
        puts "gem已安装#{n}"
    end
    r
end

def c_install n
    r = s_gem_l n
    if !r
        puts "未安装#{n}，输入安装方式（gem/homebrew）："
        install = gets.strip
        case install
        when 'gem'
            puts "正在安装#{n}:`sudo gem install #{n}`"
            syscall "sudo gem install #{n}", "安装#{n}失败"
        when 'homebrew'
            puts "正在安装#{n}:`brew install #{n}`"
            syscall "brew install #{n}", "安装#{n}失败"
        end
    end
    r
end

def main 
    puts '前置检查...'
    c_install 'cocoapods'
    c_install 'cocoapods-packager'
    puts '使用远端代码打包？（Y/N）：'
    useOrigin = gets.strip
    case useOrigin
    when "Y","y"
        $USE_ORIGIN = true
    when "N","n"
        $USE_ORIGIN = false
    else
        puts 'Illegal pargram.'
        main
    end
    package
end

main